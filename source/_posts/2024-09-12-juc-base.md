---
title: java 多线程基本使用
date: 2024-09-12 05:57:03
categories:
- java
- juc
tags:
- java
- juc
---

# 创建和运行线程

## 直接使用 Thread
```java
package com.laolang.jx;

import cn.hutool.core.util.StrUtil;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        log.info("juc hello is running...");

        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                while (true) {
                    try {
                        TimeUnit.SECONDS.sleep(5);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    log.info(StrUtil.format("thread {} is running..."), Thread.currentThread().getName());
                }
            }
        };
        t1.start();
    }
}
```

## 继承 Thread
{% tabs %}
<!-- tab SimpleThread -->
```java
package com.laolang.jx;

import cn.hutool.core.util.StrUtil;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SimpleThread extends Thread{
    public SimpleThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        while (true) {
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info(StrUtil.format("thread {} is running..."), Thread.currentThread().getName());
        }
    }
}
```
<!-- endtab -->

<!-- tab JucHelloApplication -->
```java
package com.laolang.jx;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        log.info("juc hello is running...");

        Thread t1 = new SimpleThread("t1");
        t1.start();
    }
}
```
<!-- endtab -->

{% endtabs %}

## 实现 Runnable
{% tabs %}
<!-- tab SimpleThread -->
```java
package com.laolang.jx;

import cn.hutool.core.util.StrUtil;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SimpleThread implements Runnable{

    @Override
    public void run() {
        while (true) {
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info(StrUtil.format("thread {} is running..."), Thread.currentThread().getName());
        }
    }
}
```
<!-- endtab -->

<!-- tab JucHelloApplication -->
```java
package com.laolang.jx;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        log.info("juc hello is running...");

        Thread t1 = new Thread(new SimpleThread(), "t1");
        t1.start();
    }
}
```
<!-- endtab -->

{% endtabs %}

## Callable 与 Future

### FutureTask

#### 代码

{% tabs %}
<!-- tab SimpleCallable -->
```java
package com.laolang.jx;

import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SimpleCallable implements Callable<Integer> {


    @Override
    public Integer call() {
        log.info("callabel 线程启动");
        int sum = 0;
        for (int i = 1; i <= 5; i++) {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info("callable 正在运行");
            sum += i;
        }
        log.info("callable 线程运行完毕");
        return sum;
    }
}
```
<!-- endtab -->

<!-- tab JucHelloApplication -->
```java
package com.laolang.jx;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        log.info("juc hello is running...");

        FutureTask<Integer> futureTask = new FutureTask<>(new SimpleCallable());
        Thread t1 = new Thread(futureTask, "t1");
        t1.start();

        int i = 0;
        while( i < 5 ){
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info("主线程的某些任务");
            i++;
        }

        try {
            Integer ret = futureTask.get();
            log.info("线程计算结果:{}",ret);
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }

        i = 0;
        while( i < 5 ){
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info("主线程的某些任务2");
            i++;
        }

        log.info("程序结束");
    }
}
```
<!-- endtab -->

{% endtabs %}

#### 结果

```
2024-09-12 08:05:01.920 [main ] INFO  com.laolang.jx.JucHelloApplication       - juc hello is running...
2024-09-12 08:05:01.921 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callabel 线程启动
2024-09-12 08:05:03.931 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:05:04.934 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:05:05.938 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:05:07.938 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:05:07.954 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:05:09.961 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:05:10.951 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:05:11.963 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:05:13.962 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:05:16.972 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:05:16.972 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 线程运行完毕
2024-09-12 08:05:16.972 [main ] INFO  com.laolang.jx.JucHelloApplication       - 线程计算结果:15
2024-09-12 08:05:18.979 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:05:20.996 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:05:23.013 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:05:25.020 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:05:27.035 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:05:27.037 [main ] INFO  com.laolang.jx.JucHelloApplication       - 程序结束
```

#### FutureTask 的缺陷

`get` 方法在 `Future` 计算完成之前会一直处于阻塞状态

### CompletableFuture

#### 代码

{% tabs %}
<!-- tab SimpleCallable -->
```java
package com.laolang.jx;

import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SimpleCallable implements Callable<Integer> {


    @Override
    public Integer call() {
        log.info("callabel 线程启动");
        int sum = 0;
        for (int i = 1; i <= 5; i++) {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info("callable 正在运行");
            sum += i;
        }
        log.info("callable 线程运行完毕");
        return sum;
    }
}
```
<!-- endtab -->

<!-- tab JucHelloApplication -->
```java
package com.laolang.jx;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        log.info("juc hello is running...");

        ExecutorService executorService = Executors.newFixedThreadPool(1, runnable -> {
            Thread thread = new Thread(runnable);
            thread.setName("t1");
            return thread;
        });

        CompletableFuture
                .supplyAsync(() -> new SimpleCallable().call(), executorService)
                .whenComplete((integer, throwable) -> log.info("callable 计算结果:{}", integer));

        int i = 0;
        while (i < 5) {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info("主线程的某些任务");
            i++;
        }

        i = 0;
        while (i < 5) {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info("主线程的某些任务2");
            i++;
        }

        executorService.shutdown();
        log.info("程序结束");
    }
}
```
<!-- endtab -->

{% endtabs %}

#### 结果
```
2024-09-12 08:08:11.632 [main ] INFO  com.laolang.jx.JucHelloApplication       - juc hello is running...
2024-09-12 08:08:11.655 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callabel 线程启动
2024-09-12 08:08:13.665 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:08:14.670 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:08:15.678 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:08:17.682 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:08:17.682 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:08:19.689 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:08:20.690 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:08:21.703 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务
2024-09-12 08:08:23.693 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:08:23.709 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:08:25.716 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:08:26.710 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 正在运行
2024-09-12 08:08:26.713 [t1   ] INFO  com.laolang.jx.SimpleCallable            - callable 线程运行完毕
2024-09-12 08:08:26.715 [t1   ] INFO  com.laolang.jx.JucHelloApplication       - callable 计算结果:15
2024-09-12 08:08:27.723 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:08:29.740 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:08:31.751 [main ] INFO  com.laolang.jx.JucHelloApplication       - 主线程的某些任务2
2024-09-12 08:08:31.751 [main ] INFO  com.laolang.jx.JucHelloApplication       - 程序结束
```

## 一个小例子: 分别计算奇偶数之和

### 代码
```java
package com.laolang.jx;

import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.Nonnull;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        log.info("juc hello is running...");

        ExecutorService executorService = Executors.newFixedThreadPool(2, new SimplThreadFactory("call-"));

        // 计算奇数
        CompletableFuture.supplyAsync(() -> new SimpleCallable(NumberType.ODD).call(), executorService)
                .whenComplete((integer, throwable) -> log.info("奇数之和:{}", integer));
        // 计算偶数
        CompletableFuture.supplyAsync(() -> new SimpleCallable(NumberType.EVEN).call(), executorService)
                .whenComplete((integer, throwable) -> log.info("偶数之和:{}", integer));

        int i = 0;
        while (i < 5) {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.info("主线程的某些任务");
            i++;
        }
        log.info("主线程运行完毕");

        executorService.shutdown();
    }

    /**
     * 自定义线程名称
     */
    static class SimplThreadFactory implements ThreadFactory {
        private final AtomicInteger threadIndex = new AtomicInteger(1);
        private final String threadNamePrefix;

        public SimplThreadFactory(String threadNamePrefix) {
            this.threadNamePrefix = threadNamePrefix;
        }

        @Override
        public Thread newThread(@Nonnull Runnable runnable) {
            return new Thread(runnable, threadNamePrefix + threadIndex.getAndIncrement());
        }
    }

    /**
     * 数字类型
     */
    enum NumberType {
        /**
         * 偶数
         */
        EVEN,
        /**
         * 奇数
         */
        ODD
    }

    @Slf4j
    static class SimpleCallable implements Callable<Integer> {

        private final NumberType numberType;
        @Getter
        private Integer sum = 0;

        public SimpleCallable(NumberType numberType) {
            this.numberType = numberType;
        }

        @Override
        public Integer call() {
            log.info("{} 线程启动", Thread.currentThread().getName());
            for (int i = 1; i <= 10; i++) {
                if (match(i)) {
                    try {
                        // 偶数线程 sleep 1 秒
                        // 奇数线程 sleep 2 秒
                        TimeUnit.SECONDS.sleep((i & 1) + 1);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    log.info("{} 正在运行, 累增:{}", Thread.currentThread().getName(), i);
                    sum += i;
                }
            }
            log.info("{} 线程运行完毕", Thread.currentThread().getName());
            return sum;
        }

        private boolean match(int number) {
            return numberType.ordinal() == (number & 1);
        }

    }
}
```

### 运行结果
```
2024-09-12 21:59:01.874 [main    ] INFO  c.l.jx.JucHelloApplication     - juc hello is running...
2024-09-12 21:59:01.898 [call-2  ] INFO  elloApplication$SimpleCallable - call-2 线程启动
2024-09-12 21:59:01.898 [call-1  ] INFO  elloApplication$SimpleCallable - call-1 线程启动
2024-09-12 21:59:02.903 [call-2  ] INFO  elloApplication$SimpleCallable - call-2 正在运行, 累增:2
2024-09-12 21:59:03.910 [call-2  ] INFO  elloApplication$SimpleCallable - call-2 正在运行, 累增:4
2024-09-12 21:59:03.910 [main    ] INFO  c.l.jx.JucHelloApplication     - 主线程的某些任务
2024-09-12 21:59:03.910 [call-1  ] INFO  elloApplication$SimpleCallable - call-1 正在运行, 累增:1
2024-09-12 21:59:04.922 [call-2  ] INFO  elloApplication$SimpleCallable - call-2 正在运行, 累增:6
2024-09-12 21:59:05.916 [call-1  ] INFO  elloApplication$SimpleCallable - call-1 正在运行, 累增:3
2024-09-12 21:59:05.916 [main    ] INFO  c.l.jx.JucHelloApplication     - 主线程的某些任务
2024-09-12 21:59:05.932 [call-2  ] INFO  elloApplication$SimpleCallable - call-2 正在运行, 累增:8
2024-09-12 21:59:06.946 [call-2  ] INFO  elloApplication$SimpleCallable - call-2 正在运行, 累增:10
2024-09-12 21:59:06.946 [call-2  ] INFO  elloApplication$SimpleCallable - call-2 线程运行完毕
2024-09-12 21:59:06.947 [call-2  ] INFO  c.l.jx.JucHelloApplication     - 偶数之和:30
2024-09-12 21:59:07.925 [call-1  ] INFO  elloApplication$SimpleCallable - call-1 正在运行, 累增:5
2024-09-12 21:59:07.925 [main    ] INFO  c.l.jx.JucHelloApplication     - 主线程的某些任务
2024-09-12 21:59:09.929 [call-1  ] INFO  elloApplication$SimpleCallable - call-1 正在运行, 累增:7
2024-09-12 21:59:09.929 [main    ] INFO  c.l.jx.JucHelloApplication     - 主线程的某些任务
2024-09-12 21:59:11.945 [main    ] INFO  c.l.jx.JucHelloApplication     - 主线程的某些任务
2024-09-12 21:59:11.945 [call-1  ] INFO  elloApplication$SimpleCallable - call-1 正在运行, 累增:9
2024-09-12 21:59:11.945 [main    ] INFO  c.l.jx.JucHelloApplication     - 主线程运行完毕
2024-09-12 21:59:11.945 [call-1  ] INFO  elloApplication$SimpleCallable - call-1 线程运行完毕
2024-09-12 21:59:11.945 [call-1  ] INFO  c.l.jx.JucHelloApplication     - 奇数之和:25
```

### 参考
[自定义 ExecutorService 中线程的名称](https://springdoc.cn/java-naming-executor-service-thread/)

# 多线程经典例子 · 买票

## synchronized 方式实现
### 代码
```java
package com.laolang.jx;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(new TicketRunnable(ticket), "t1");
        Thread t2 = new Thread(new TicketRunnable(ticket), "t2");
        Thread t3 = new Thread(new TicketRunnable(ticket), "t3");
        t1.start();
        t2.start();
        t3.start();

    }
}

@Slf4j
@Data
class Ticket {
    /**
     * 总票数
     */
    private Integer total = 30;

    /**
     * 买票
     */
    public synchronized void sale() {
        if (total > 0) {
            total--;
            log.info("{} 卖出:{},剩下:{}", Thread.currentThread().getName(), 1, total);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

@RequiredArgsConstructor
@Data
class TicketRunnable implements Runnable{

    private final Ticket ticket;

    @Override
    public void run() {
        for (int i = 0; i < 40; i++) {
            ticket.sale();
        }
    }
}
```

### 运行效果
```
2024-10-05 04:39:54.338 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:29
2024-10-05 04:39:56.353 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:28
2024-10-05 04:39:58.364 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:27
2024-10-05 04:40:00.375 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:26
2024-10-05 04:40:02.388 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:25
2024-10-05 04:40:04.398 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:24
2024-10-05 04:40:06.408 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:23
2024-10-05 04:40:08.418 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:22
2024-10-05 04:40:10.436 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:21
2024-10-05 04:40:12.446 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:20
2024-10-05 04:40:14.456 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:19
2024-10-05 04:40:16.467 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:18
2024-10-05 04:40:18.479 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:17
2024-10-05 04:40:20.483 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:16
2024-10-05 04:40:22.497 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:15
2024-10-05 04:40:24.504 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:14
2024-10-05 04:40:26.511 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:13
2024-10-05 04:40:28.521 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:12
2024-10-05 04:40:30.531 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:11
2024-10-05 04:40:32.543 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:10
2024-10-05 04:40:34.556 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:9
2024-10-05 04:40:36.564 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:8
2024-10-05 04:40:38.577 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:7
2024-10-05 04:40:40.585 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:6
2024-10-05 04:40:42.599 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:5
2024-10-05 04:40:44.600 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:4
2024-10-05 04:40:46.613 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:3
2024-10-05 04:40:48.622 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:2
2024-10-05 04:40:50.627 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:1
2024-10-05 04:40:52.640 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:0
```

## Lock 方式实现

### 代码
```java
package com.laolang.jx;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(new TicketRunnable(ticket), "t1");
        Thread t2 = new Thread(new TicketRunnable(ticket), "t2");
        Thread t3 = new Thread(new TicketRunnable(ticket), "t3");
        t1.start();
        t2.start();
        t3.start();

    }
}

@Slf4j
@Data
class Ticket {
    /**
     * 总票数
     */
    private Integer total = 30;

    /**
     * 可重入锁
     */
    private final ReentrantLock lock = new ReentrantLock();

    /**
     * 买票
     */
    public synchronized void sale() {
        try{
            lock.lock();
            if (total > 0) {
                total--;
                log.info("{} 卖出:{},剩下:{}", Thread.currentThread().getName(), 1, total);
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }finally {
            lock.unlock();
        }
    }
}

@RequiredArgsConstructor
@Data
class TicketRunnable implements Runnable{

    private final Ticket ticket;

    @Override
    public void run() {
        for (int i = 0; i < 40; i++) {
            ticket.sale();
        }
    }
}
```

### 运行效果
```
2024-10-05 04:44:58.522 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:29
2024-10-05 04:45:00.536 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:28
2024-10-05 04:45:02.544 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:27
2024-10-05 04:45:04.559 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:26
2024-10-05 04:45:06.567 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:25
2024-10-05 04:45:08.577 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:24
2024-10-05 04:45:10.583 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:23
2024-10-05 04:45:12.588 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:22
2024-10-05 04:45:14.590 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:21
2024-10-05 04:45:16.598 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:20
2024-10-05 04:45:18.617 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:19
2024-10-05 04:45:20.631 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:18
2024-10-05 04:45:22.642 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:17
2024-10-05 04:45:24.648 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:16
2024-10-05 04:45:26.661 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:15
2024-10-05 04:45:28.667 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:14
2024-10-05 04:45:30.674 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:13
2024-10-05 04:45:32.685 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:12
2024-10-05 04:45:34.691 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:11
2024-10-05 04:45:36.699 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:10
2024-10-05 04:45:38.705 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:9
2024-10-05 04:45:40.718 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:8
2024-10-05 04:45:42.726 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:7
2024-10-05 04:45:44.739 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:6
2024-10-05 04:45:46.751 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:5
2024-10-05 04:45:48.768 [t2   ] INFO  com.laolang.jx.Ticket          - t2 卖出:1,剩下:4
2024-10-05 04:45:50.776 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:3
2024-10-05 04:45:52.789 [t3   ] INFO  com.laolang.jx.Ticket          - t3 卖出:1,剩下:2
2024-10-05 04:45:54.794 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:1
2024-10-05 04:45:56.810 [t1   ] INFO  com.laolang.jx.Ticket          - t1 卖出:1,剩下:0
```

# 线程间通信

## 两种方式

1. 共享内存
2. 消息传递

## 一个经典例子

> 两个线程, 一个对当前数值加 1 ,另一个线程对当前数值减 1, 要求用线程间通信

### synchronized 方式实现

#### 代码
```java
package com.laolang.jx;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Share share = new Share();
        Thread t1 = new Thread(new ShareRunnable(share, OpType.INCREMENT), "t-increment");
        Thread t2 = new Thread(new ShareRunnable(share, OpType.DECREMENT), "t-decrement");
        t1.start();
        t2.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("result:{}", share.getNumber());

    }
}

@Slf4j
@Getter
class Share {
    private Integer number = 0;

    public synchronized void increment() throws InterruptedException {
        if (0 != number) {
            log.info("{}::wait", Thread.currentThread().getName());
            this.wait();
        }

        number++;
        log.info("{}::{}", Thread.currentThread().getName(), number);
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        if (1 != number) {
            log.info("{}::wait", Thread.currentThread().getName());
            this.wait();
        }

        number--;
        log.info("{}::{}", Thread.currentThread().getName(), number);
        this.notifyAll();
    }
}

enum OpType {
    INCREMENT,
    DECREMENT
}

@RequiredArgsConstructor
class ShareRunnable implements Runnable {

    private final Share share;

    private final OpType type;

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            if (type == OpType.INCREMENT) {
                try {
                    share.increment();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            } else {
                try {
                    share.decrement();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}
```

#### 运行效果
```
2024-10-05 05:02:04.331 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.333 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.333 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.333 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.333 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.333 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.333 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.333 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.334 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.334 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.335 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.335 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.335 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.335 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.335 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.335 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.335 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.335 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.335 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.335 [t-increment] INFO  com.laolang.jx.Share           - t-increment::wait
2024-10-05 05:02:04.335 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:04.335 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::wait
2024-10-05 05:02:04.335 [t-increment] INFO  com.laolang.jx.Share           - t-increment::1
2024-10-05 05:02:04.335 [t-decrement] INFO  com.laolang.jx.Share           - t-decrement::0
2024-10-05 05:02:05.341 [main       ] INFO  c.l.jx.JucHelloApplication     - result:0
```

#### 虚假唤醒问题
修改代码如下
```java
@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Share share = new Share();
        Thread t1 = new Thread(new ShareRunnable(share, OpType.INCREMENT), "t-in-1");
        Thread t2 = new Thread(new ShareRunnable(share, OpType.DECREMENT), "t-de-1");
        Thread t3 = new Thread(new ShareRunnable(share, OpType.INCREMENT), "t-in-2");
        Thread t4 = new Thread(new ShareRunnable(share, OpType.DECREMENT), "t-de-2");
        t1.start();
        t2.start();
        t3.start();
        t4.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("result:{}", share.getNumber());
    }
}
```

运行效果

{% note info no-icon simple %}
出现了 **-1**
{% endnote %}

```
2024-10-05 05:05:20.180 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::1
2024-10-05 05:05:20.182 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::wait
2024-10-05 05:05:20.183 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::0
2024-10-05 05:05:20.183 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.183 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.183 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::1
2024-10-05 05:05:20.183 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::wait
2024-10-05 05:05:20.183 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::0
2024-10-05 05:05:20.183 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.183 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::-1
2024-10-05 05:05:20.183 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.183 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::0
2024-10-05 05:05:20.183 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::1
2024-10-05 05:05:20.183 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::wait
2024-10-05 05:05:20.183 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::0
2024-10-05 05:05:20.183 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.183 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::-1
2024-10-05 05:05:20.184 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.184 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::0
2024-10-05 05:05:20.184 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::1
2024-10-05 05:05:20.184 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::wait
2024-10-05 05:05:20.184 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::0
2024-10-05 05:05:20.184 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.184 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::-1
2024-10-05 05:05:20.184 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.184 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::0
2024-10-05 05:05:20.184 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::1
2024-10-05 05:05:20.184 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::wait
2024-10-05 05:05:20.184 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::0
2024-10-05 05:05:20.184 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.184 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::-1
2024-10-05 05:05:20.184 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.184 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::0
2024-10-05 05:05:20.184 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::1
2024-10-05 05:05:20.184 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::wait
2024-10-05 05:05:20.184 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::0
2024-10-05 05:05:20.184 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.184 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::-1
2024-10-05 05:05:20.185 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.185 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::0
2024-10-05 05:05:20.185 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::1
2024-10-05 05:05:20.185 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::wait
2024-10-05 05:05:20.185 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::0
2024-10-05 05:05:20.185 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.185 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::-1
2024-10-05 05:05:20.185 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.185 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::0
2024-10-05 05:05:20.185 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::1
2024-10-05 05:05:20.185 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::wait
2024-10-05 05:05:20.185 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::0
2024-10-05 05:05:20.186 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.186 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::-1
2024-10-05 05:05:20.186 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.186 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::0
2024-10-05 05:05:20.186 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::1
2024-10-05 05:05:20.186 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::wait
2024-10-05 05:05:20.186 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::0
2024-10-05 05:05:20.186 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::wait
2024-10-05 05:05:20.186 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::-1
2024-10-05 05:05:20.186 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.186 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::0
2024-10-05 05:05:20.186 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::1
2024-10-05 05:05:20.186 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::wait
2024-10-05 05:05:20.186 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::0
2024-10-05 05:05:20.186 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::wait
2024-10-05 05:05:20.186 [t-de-2     ] INFO  com.laolang.jx.Share           - t-de-2::-1
2024-10-05 05:05:20.186 [t-in-1     ] INFO  com.laolang.jx.Share           - t-in-1::0
2024-10-05 05:05:20.186 [t-de-1     ] INFO  com.laolang.jx.Share           - t-de-1::-1
2024-10-05 05:05:20.186 [t-in-2     ] INFO  com.laolang.jx.Share           - t-in-2::0
2024-10-05 05:05:21.184 [main       ] INFO  c.l.jx.JucHelloApplication     - result:0
```

原因: 当某个线程 `wait` 之后又抢到锁, 就会继续执行 `wait` 之后的代码,此时 `if` 判断不会执行, 导致运行逻辑不正确
解决方式: 把 `wait` 放到循环中

```java
@Slf4j
@Getter
class Share {
    private Integer number = 0;

    public synchronized void increment() throws InterruptedException {
        while (0 != number) {
            log.info("{}::wait", Thread.currentThread().getName());
            this.wait();
        }

        number++;
        log.info("{}::{}", Thread.currentThread().getName(), number);
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        while (1 != number) {
            log.info("{}::wait", Thread.currentThread().getName());
            this.wait();
        }

        number--;
        log.info("{}::{}", Thread.currentThread().getName(), number);
        this.notifyAll();
    }
}
```

### Lock 方式实现

#### 代码
```java
@Slf4j
@Getter
class Share {
    private Integer number = 0;

    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    public void increment() throws InterruptedException {
        try {
            lock.lock();
            while (0 != number) {
                log.info("{}::wait", Thread.currentThread().getName());
                condition.await();
            }

            number++;
            log.info("{}::{}", Thread.currentThread().getName(), number);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() throws InterruptedException {
        try {
            lock.lock();
            while (1 != number) {
                log.info("{}::wait", Thread.currentThread().getName());
                condition.await();
            }

            number--;
            log.info("{}::{}", Thread.currentThread().getName(), number);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}
```

## 线程间定制化通信

A 线程打印 1 次 A , B 线程打印 2 次 B , C 线程打印 3 次 C , 按照此顺序循环 3 次

### 代码
```java
package com.laolang.jx;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Share share = new Share();
        Thread t1 = new Thread(new ShareRunnable(share, OpType.A), "t-A");
        Thread t2 = new Thread(new ShareRunnable(share, OpType.B), "t-B");
        Thread t3 = new Thread(new ShareRunnable(share, OpType.C), "t-C");
        t1.start();
        t2.start();
        t3.start();
    }
}

@Getter
@RequiredArgsConstructor
enum OpType {
    A(1),
    B(2),
    C(3);

    private final Integer times;
}

@Slf4j
class Share {
    private OpType flag = OpType.A;

    private final Lock lock = new ReentrantLock();
    private final Condition conditionA = lock.newCondition();
    private final Condition conditionB = lock.newCondition();
    private final Condition conditionC = lock.newCondition();

    public void printA(int loop) throws InterruptedException {
        try {
            lock.lock();
            while (OpType.A != flag) {
                conditionA.await();
            }

            for (int i = 1; i <= flag.getTimes(); i++) {
                log.info("{}::A-{}::loop-{}", Thread.currentThread().getName(), i, loop);
            }

            flag = OpType.B;
            conditionB.signal();
        } finally {
            lock.unlock();
        }
    }

    public void printB(int loop) throws InterruptedException {
        try {
            lock.lock();
            while (OpType.B != flag) {
                conditionB.await();
            }

            for (int i = 1; i <= flag.getTimes(); i++) {
                log.info("{}::B-{}::loop-{}", Thread.currentThread().getName(), i, loop);
            }

            flag = OpType.C;
            conditionC.signal();
        } finally {
            lock.unlock();
        }
    }

    public void printC(int loop) throws InterruptedException {
        try {
            lock.lock();
            while (OpType.C != flag) {
                conditionC.await();
            }

            for (int i = 1; i <= flag.getTimes(); i++) {
                log.info("{}::C-{}::loop-{}", Thread.currentThread().getName(), i, loop);
            }

            flag = OpType.A;
            conditionA.signal();
        } finally {
            lock.unlock();
        }
    }
}

@RequiredArgsConstructor
class ShareRunnable implements Runnable {

    private final Share share;
    private final OpType type;

    @SneakyThrows
    @Override
    public void run() {
        for (int i = 1; i <= 3; i++) {
            switch (type) {
                case A: {
                    share.printA(i);
                    break;
                }
                case B: {
                    share.printB(i);
                    break;
                }
                case C: {
                    share.printC(i);
                    break;
                }
            }
        }
    }
}
```
### 运行效果
```
2024-10-05 05:46:02.271 [t-A        ] INFO  com.laolang.jx.Share           - t-A::A-1::loop-1
2024-10-05 05:46:02.273 [t-B        ] INFO  com.laolang.jx.Share           - t-B::B-1::loop-1
2024-10-05 05:46:02.273 [t-B        ] INFO  com.laolang.jx.Share           - t-B::B-2::loop-1
2024-10-05 05:46:02.273 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-1::loop-1
2024-10-05 05:46:02.273 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-2::loop-1
2024-10-05 05:46:02.273 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-3::loop-1
2024-10-05 05:46:02.273 [t-A        ] INFO  com.laolang.jx.Share           - t-A::A-1::loop-2
2024-10-05 05:46:02.273 [t-B        ] INFO  com.laolang.jx.Share           - t-B::B-1::loop-2
2024-10-05 05:46:02.273 [t-B        ] INFO  com.laolang.jx.Share           - t-B::B-2::loop-2
2024-10-05 05:46:02.274 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-1::loop-2
2024-10-05 05:46:02.274 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-2::loop-2
2024-10-05 05:46:02.274 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-3::loop-2
2024-10-05 05:46:02.274 [t-A        ] INFO  com.laolang.jx.Share           - t-A::A-1::loop-3
2024-10-05 05:46:02.274 [t-B        ] INFO  com.laolang.jx.Share           - t-B::B-1::loop-3
2024-10-05 05:46:02.274 [t-B        ] INFO  com.laolang.jx.Share           - t-B::B-2::loop-3
2024-10-05 05:46:02.274 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-1::loop-3
2024-10-05 05:46:02.274 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-2::loop-3
2024-10-05 05:46:02.274 [t-C        ] INFO  com.laolang.jx.Share           - t-C::C-3::loop-3
```

# 集合线程安全问题

## ArrayList 线程安全问题

```java
package com.laolang.jx;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

抛出异常
```
Exception in thread "1" Exception in thread "0" Exception in thread "3" java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:907)
	at java.util.ArrayList$Itr.next(ArrayList.java:857)
	at java.util.AbstractCollection.toString(AbstractCollection.java:461)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.laolang.jx.JucHelloApplication.lambda$main$0(JucHelloApplication.java:16)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:907)
	at java.util.ArrayList$Itr.next(ArrayList.java:857)
	at java.util.AbstractCollection.toString(AbstractCollection.java:461)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.laolang.jx.JucHelloApplication.lambda$main$0(JucHelloApplication.java:16)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:907)
	at java.util.ArrayList$Itr.next(ArrayList.java:857)
	at java.util.AbstractCollection.toString(AbstractCollection.java:461)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.laolang.jx.JucHelloApplication.lambda$main$0(JucHelloApplication.java:16)
	at java.lang.Thread.run(Thread.java:748)
5:51:55: Execution finished ':juc-hello:JucHelloApplication.main()'.
```

## 解决方案一 Vector
```java
package com.laolang.jx;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.Vector;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        List<String> list = new Vector<>();

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

## 解决方案一 Collections
```java
package com.laolang.jx;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        List<String> list = Collections.synchronizedList(new ArrayList<>());

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

## 解决方案一 CopyOnWriteArrayList
```java
package com.laolang.jx;

import java.util.List;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArrayList;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class JucHelloApplication {
    public static void main(String[] args) {
        List<String> list = new CopyOnWriteArrayList<>();

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString());
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}
```

# 线程工具类

## CountDownLatch

### 四个方法
```
CountDownLatch(int count); //构造方法，创建一个值为count 的计数器。
​
await();//阻塞当前线程，将当前线程加入阻塞队列。
​
await(long timeout, TimeUnit unit);//在timeout的时间之内阻塞当前线程,时间一过则当前线程可以执行，
​
countDown();//对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程。
```

### 一个示例
```java

//用于聚合所有的统计指标
private static Map map=new HashMap();
//创建计数器，这里需要统计4个指标
private static CountDownLatch countDownLatch=new CountDownLatch(4);
​
public static void main(String[] args) {
​
    //记录开始时间
    long startTime=System.currentTimeMillis();
​
    Thread countUserThread=new Thread(new Runnable() {
        public void run() {
            try {
                System.out.println("正在统计新增用户数量");
                Thread.sleep(3000);//任务执行需要3秒
                map.put("userNumber",1);//保存结果值
                countDownLatch.countDown();//标记已经完成一个任务
                System.out.println("统计新增用户数量完毕");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
​
        }
    });
    Thread countOrderThread=new Thread(new Runnable() {
        public void run() {
            try {
                System.out.println("正在统计订单数量");
                Thread.sleep(3000);//任务执行需要3秒
                map.put("countOrder",2);//保存结果值
                countDownLatch.countDown();//标记已经完成一个任务
                System.out.println("统计订单数量完毕");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
​
        }
    });
​
    Thread countGoodsThread=new Thread(new Runnable() {
        public void run() {
            try {
                System.out.println("正在商品销量");
                Thread.sleep(3000);//任务执行需要3秒
                map.put("countGoods",3);//保存结果值
                countDownLatch.countDown();//标记已经完成一个任务
                System.out.println("统计商品销量完毕");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
​
        }
    });
​
    Thread countmoneyThread=new Thread(new Runnable() {
        public void run() {
            try {
                System.out.println("正在总销售额");
                Thread.sleep(3000);//任务执行需要3秒
                map.put("countmoney",4);//保存结果值
                countDownLatch.countDown();//标记已经完成一个任务
                System.out.println("统计销售额完毕");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
​
        }
    });
    //启动子线程执行任务
    countUserThread.start();
    countGoodsThread.start();
    countOrderThread.start();
    countmoneyThread.start();
​
    try {
        //主线程等待所有统计指标执行完毕
        countDownLatch.await();
        long endTime=System.currentTimeMillis();//记录结束时间
        System.out.println("------统计指标全部完成--------");
        System.out.println("统计结果为："+map.toString());
        System.out.println("任务总执行时间为"+(endTime-startTime)/1000+"秒");
​
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

# 阻塞队列

## ArrayBlockingQueue

`ArrayBlockingQueue` 和 `LinkedBlockingQueue`
1. `ArrayBlockingQueue` 在生产者和消费者获取数据, 都是公用一个锁对象, 由此也意味着两者无法并行执行. 
2. `ArrayBlockingQueue` 插入或删除元素时不会产生或销毁任何额外的对象实例, 而 `LinkedBlockingQueue` 会生成一个额外的 `Node` 对象, 这在长时间内需要高效并发处理大批量数据时, 其对于 GC 的影响还是有一定的区别, `ArrayBlockingQueue` 默认使用非公平锁

```java
package com.laolang.jx;

import java.util.NoSuchElementException;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import org.testng.Assert;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;

public class BlockingQueueTest {

    private BlockingQueue<String> queue;
    private final Integer queueSize = 3;

    @BeforeTest
    public void beforeTest() {
        queue = null;
        queue = new ArrayBlockingQueue<>(queueSize);
    }

    /**
     * <code>add</code> 方法可以添加, <code>element</code> 方法可以查看元素
     */
    @Test
    public void testAdd() {
        queue.add("a");
        queue.add("b");
        queue.add("c");
        Assert.assertEquals(queue.element(), "a");
    }

    /**
     * 超出最大容量, 会报异常
     */
    @Test(expectedExceptions = IllegalStateException.class)
    public void testAddException() {
        queue.add("a");
        queue.add("b");
        queue.add("c");
        queue.add("d");
    }

    /**
     * <code>remove</code> 方法可以取出元素
     */
    @Test
    public void testRemove() {
        queue.add("a");
        queue.add("b");
        queue.add("c");
        String remove = queue.remove();
        Assert.assertEquals(remove, "a");
        Assert.assertEquals(queue.element(), "b");
    }

    /**
     * 如果队列为空, <code>remove</code> 方法会报异常
     */
    @Test(expectedExceptions = NoSuchElementException.class)
    public void testRemoveException() {
        queue.add("a");
        queue.add("b");
        queue.add("c");
        queue.remove();
        queue.remove();
        queue.remove();
        queue.remove();
    }

    /**
     * <code>offer</code> 方法返回添加是否成功, <code>poll</code> 方法如果没有取到则返回 <code>null</code>
     */
    @Test
    public void testOfferAndPoll() {
        Assert.assertTrue(queue.offer("a"));
        Assert.assertTrue(queue.offer("b"));
        Assert.assertTrue(queue.offer("c"));
        Assert.assertFalse(queue.offer("d"));
        Assert.assertEquals(queue.poll(), "a");
        Assert.assertEquals(queue.poll(), "b");
        Assert.assertEquals(queue.poll(), "c");
        Assert.assertNull(queue.poll());
    }

    /**
     * <code>put</code> 方法在队列已满时会阻塞
     */
    @Test
    public void testPut() throws InterruptedException {
        queue.put("a");
        queue.put("b");
        queue.put("c");
        queue.put("c"); // 此时会阻塞
    }

    /**
     * <code>take</code> 方法在队列空时会阻塞
     */
    @Test
    public void testTake() throws InterruptedException {
        queue.put("a");
        queue.put("b");
        queue.put("c");

        Assert.assertEquals(queue.take(), "a");
        Assert.assertEquals(queue.take(), "b");
        Assert.assertEquals(queue.take(), "c");
        queue.take(); // 此时会阻塞
    }
}
```

## LinkedBlockingQueue
`LinkedBlockingQueue` 生产者和消费者分别采用了独立的锁来控制数据同步
在生产者放入一个数据时, 队列会从生产者中获取数据,并缓存在队列内部, 而生产者立即返回; 只有当队列缓冲区达到最大值缓存容量时, 才会阻塞生产者队列, 指导消费者从队列中消费掉一份数据, 生产者线程会被唤醒, 繁殖对于消费者的处理也是一样.


# 线程池

## 线程池的参数

|参数|含义|
|--|--|
|corePoolSize    | 线程池的核心线程数|
|maximumPoolSize | 能容纳的最大线程数|
|keepAliveTime   | 空闲线程存活时间|
|unit            | 存活的时间单位|
|workQueue       | 存放提交但未执行任务的队列|
|threadFactory   | 创建线程的工厂类|
|handler         | 当代队列满后的拒绝策略|

## 拒绝策略
|策略|含义|
|--|--|
|`CallerRunsPolicy`|当触发拒绝策略, 只要线程池没有关闭的话, 则使用调用线程直接运行任务. 一般并发比较小, 性能要求不高, 不允许失败. 但是, 由于调用者自己运行任务, 四任务提交速度过快, 可能导致程序阻塞, 性能效率上必然有损失|
|`AbortPolicy`|丢弃任务, 并抛出拒绝执行 `RejectedExecutionException` 异常信息. 线程池默认的拒绝策略. 必须处理好抛出的异常, 否则会打断当前的执行流程, 影响后续的人物执行|
|`DiscardPolicy`|丢弃|
|`DiscardOldestPolicy`|当触发拒绝策略, 只要线程池没有关闭的话, 丢弃阻塞队列 `workQueue` 中最老的一个任务, 并将新的任务加入|



## 线程池的种类

### newCachedThreadPool

**作用**

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程

**特点**

* 线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）
* 线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）
* 当线程池中，没有可用线程，会重新创建一个线程

**创建方式**
```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
}
```

**场景**
适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景

### newFixedThreadPool

**作用**

创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。

*特征**

* 线程池中的线程处于一定的量，可以很好的控制线程的并发量
* 线程可以重复被使用，在显示关闭之前，都将一直存在
* 超出一定量的线程被提交时候需在队列中等待

**创建方式**
```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(),
                                    threadFactory);
}
```

**场景**
适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景

## newSingleThreadExecutor

**作用**
创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。

**特征**
线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行

**创建方式**
```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

**场景**
适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景

##  newScheduleThreadPool
**作用**
线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池**
**特征**
1. 线程池中具有指定数量的线程，即便是空线程也将保留 
2. 可定时或者延迟执行线程活动

**创建方式**
```java
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```
**场景**
适用于需要多个后台线程执行周期任务的场景

## newWorkStealingPool

jdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务

**创建方式**
```java
public static ExecutorService newWorkStealingPool(int parallelism) {
    return new ForkJoinPool
            (parallelism,
                    ForkJoinPool.defaultForkJoinWorkerThreadFactory,
                    null, true);
}

/**
 * 
 * @param parallelism 并行界别
 * @param factory 用户创建 ForkJoinPool 中使用的线程
 * @param handler 用于处理工作线程未处理的异常
 * @param asyncMode 用于控制 WorkQueue 的工作模式
 */
public ForkJoinPool(int parallelism,
                    ForkJoinPool.ForkJoinWorkerThreadFactory factory,
                    Thread.UncaughtExceptionHandler handler,
                    boolean asyncMode)
```

**场景**
适用于大耗时，可并行执行的场景

## 原理

1. 在创建了线程池后，线程池中的线程数为零
2. 当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： 
2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； 
2.3 如果这个时候队列满了且正在运行的线程数量还小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 
2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。
3. 当一个线程完成任务时，它会从队列中取下一个任务来执行
4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：
4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 
4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。

## 注意事项

项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用LinkedBlockingQueue 实现的，这个队列最大长度 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池

![](/images/2024-09-12-juc-base/001.png)