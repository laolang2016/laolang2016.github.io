---
title: shiro 基础
date: 2024-09-22 15:25:01
categories:
- java
- 认证与授权
- shiro
tags:
- java
- 认证与授权
- shiro
---

# 参考资料汇总

[shiro 官网](https://shiro.apache.org/)

在这里: [https://shiro.apache.org/release-archive.html](https://shiro.apache.org/release-archive.html) 可以下载完整的源码

![](/images/2024-09-22-shiro-基础/001.png)


[跟我学Shiro目录贴](https://www.iteye.com/category/305053)

[黑马程序员Java高级工程师技术栈-由浅入深掌握Shiro权限框架](https://www.bilibili.com/video/BV1j54y1t7jM)
[Shiro 入门到实战](https://www.bilibili.com/video/BV1vE411i7ij)
[【专题精讲】最新Shiro安全框架实战，由浅入深掌握Shiro权限框架](https://www.bilibili.com/video/BV1BN411w7Pd)

[springboot shiro 多realm配置认证、授权](https://www.cnblogs.com/skyLogin/p/10871347.html)
[shiro配置多个realm的方式](https://blog.csdn.net/weixin_43897590/article/details/105890842)

# 基本概念及入门

## hello world

### pom.xml

{% note info no-icon simple %}
`commons-logging` 依赖必须添加, 否则会报错:
**java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory**
{% endnote %}


```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.laolang.jx</groupId>
    <artifactId>shiro-hello</artifactId>
    <version>0.1</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>

        <maven-compiler-plugin.version>3.11.0</maven-compiler-plugin.version>
        <maven-resources-plugin.version>2.7</maven-resources-plugin.version>
        <maven-surefire-plugin.version>3.2.3</maven-surefire-plugin.version>

        <!-- shiro -->
        <shiro.version>1.13.0</shiro.version>

        <!-- 日志 -->
        <logback.version>1.2.12</logback.version>
        <commons-logging.version>1.3.0</commons-logging.version>

        <!-- test -->
        <testng.version>6.14.3</testng.version>

        <!-- tool -->
        <lombok.version>1.18.30</lombok.version>
        <hutool.version>5.8.11</hutool.version>
        <commons-lang3.version>3.12.0</commons-lang3.version>
    </properties>

    <dependencies>
        <!-- shiro -->
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-core</artifactId>
            <version>1.13.0</version>
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-api</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!-- 日志 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>${commons-logging.version}</version>
        </dependency>

        <!-- testng -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>${testng.version}</version>
        </dependency>

        <!-- tool -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
        </dependency>
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>${hutool.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
    </dependencies>

    <build>
        <finalName>${project.artifactId}</finalName>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
            </resource>
        </resources>
        <testResources>
            <testResource>
                <directory>src/test/java</directory>
                <includes>
                    <include>**/*.ini</include>
                </includes>
            </testResource>
        </testResources>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>${maven-resources-plugin.version}</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
                <configuration>
                    <testFailureIgnore>true</testFailureIgnore>
                    <argLine>-Dfile.encoding=UTF-8</argLine>
                    <suiteXmlFiles>
                        <suiteXmlFile>testng.xml</suiteXmlFile>
                    </suiteXmlFiles>
                </configuration>
            </plugin>
        </plugins>
    </build>


    <repositories>
        <repository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>https://maven.aliyun.com/repository/public</url>
            <releases>
                <enabled>true</enabled>
            </releases>
        </repository>
    </repositories>

    <pluginRepositories>
        <pluginRepository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>https://maven.aliyun.com/repository/public</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>
</project>
```

### shiro-hello.ini
```ini
# 用户信息
[users]
zhang=123
wang=456
```

### 测试类
```java
package com.laolang.jx.hello;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.testng.Assert;
import org.testng.annotations.Test;

@Slf4j
public class HelloWorldTest {

    @Test
    public void testHelloWorld(){
        // 1. 获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager
        Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:com/laolang/jx/hello/shiro-hello.ini");
        // 2. 得到SecurityManager实例 并绑定给SecurityUtils
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");

        try{
            // 4. 登录
            subject.login(token);
        }catch (AuthenticationException e){
            // 5. 身份验证失败
            log.error("身份验证失败 :{}", ExceptionUtils.getMessage(e));
        }

        Assert.assertTrue(subject.isAuthenticated());

        // 6. 退出
        subject.logout();
    }
}
```

## 自定义 Realm

### Realm 介绍

`Realm`: 域. `Shiro` 从 `Realm` 获取安全数据（如用户、角色、权限），就是说 `SecurityManager` 要验证用户身份，那么它需要从 `Realm` 获取相应的用户进行比较以确定用户身份是否合法；也需要从 `Realm` 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 `Realm` 看成 `DataSource` ，即安全数据源。如我们之前的ini配置方式将使用 `org.apache.shiro.realm.text.IniRealm`。

`Realm` 接口如下

```java
public interface Realm {

    /**
     * 返回一个唯一的 Realm 名字 
     */
    String getName();

    /**
     * 判断此 Realm 是否支持此 Token
     */
    boolean supports(AuthenticationToken token);

    /**
     * 根据 Token 获取认证信息
     */
    AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;
}
```

### shiro 默认提供的 Realm
{% mermaid %}
classDiagram
    class Realm
    <<interface>> Realm
    class CachingRealm
    CachingRealm : 带有缓存的 Realm
    class AuthenticatingRealm
    AuthenticatingRealm : 支持认证的 Realm
    class AuthorizingRealm
    AuthorizingRealm : 支持授权的 Realm
    class SimpleAccountRealm
    class TextConfigurationRealm
    class PropertiesRealm
    class IniRealm
    class JdbcRealm
    class JndiLdapRealm
    class AbstractLdapRealm
    class ActiveDirectoryRealm

    Realm <|--  CachingRealm
    CachingRealm <|--  AuthenticatingRealm
    AuthenticatingRealm <|--  AuthorizingRealm
    AuthorizingRealm <|--  SimpleAccountRealm
    SimpleAccountRealm <|--  TextConfigurationRealm
    TextConfigurationRealm <|--  PropertiesRealm
    TextConfigurationRealm <|--  IniRealm
    AuthorizingRealm <|--  JdbcRealm
    AuthorizingRealm <|--  JndiLdapRealm
    AuthorizingRealm <|--  AbstractLdapRealm
    AbstractLdapRealm <|--  ActiveDirectoryRealm
{% endmermaid %}

### shiro-custom-realm.ini
```ini
# 声明一个 realm
customRealm= com.laolang.jx.customrealm.CustomRealm
# 指定securityManager的realms实现
securityManager.realms=$customRealm
```
### 简单的自定义 Realm

#### CustomRealm.java
```java
package com.laolang.jx.customrealm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.realm.Realm;

/**
 * 自定义 Realm
 */
public class CustomRealm implements Realm {

    @Override
    public String getName() {
        return "customRealm";
    }

    /**
     * 仅支持  UsernamePasswordToken
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        return token instanceof UsernamePasswordToken;
    }

    @Override
    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // 用户名
        String username = (String) token.getPrincipal();
        // 密码
        String password = new String((char[]) token.getCredentials());

        // 用户名错误
        if (!"zhang".equals(username)) {
            throw new UnknownAccountException();
        }

        // 密码错误
        if (!"123".equals(password)) {
            throw new IncorrectCredentialsException();
        }

        // 如果身份验证成功, 则返回一个 AuthenticationInfo 的实现
        return new SimpleAuthenticationInfo(username, password, getName());
    }
}
```

#### 测试
```java
package com.laolang.jx.customrealm;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.testng.Assert;
import org.testng.annotations.Test;

@Slf4j
public class CustomRealmTest {

    @Test
    public void testCustomRealm() {
        // 1. 获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager
        Factory<SecurityManager> factory = 
            new IniSecurityManagerFactory("classpath:com/laolang/jx/customrealm/shiro-custom-realm.ini");
        // 2. 得到SecurityManager实例 并绑定给SecurityUtils
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");

        try {
            // 4. 登录
            subject.login(token);
        } catch (AuthenticationException e) {
            // 5. 身份验证失败
            log.error("身份验证失败 :{}", ExceptionUtils.getMessage(e));
        }

        Assert.assertTrue(subject.isAuthenticated());

        // 6. 退出
        subject.logout();
    }
}
```

### AuthorizingRealm
一般都是继承 `AuthorizingRealm`, 带有认证和授权功能, 有两个方法
```java
public abstract class AuthorizingRealm extends AuthenticatingRealm
        implements Authorizer, Initializable, PermissionResolverAware, RolePermissionResolverAware {

    /**
     * 认证
     */
    protected abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;

    /**
     * 授权
     */
    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);
}
```

#### 继承 AuthorizingRealm
```java
package com.laolang.jx.authorizingrealm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

public class CustomAuthorizingRealm extends AuthorizingRealm {

    /**
     * 认证
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // 用户名
        String username = (String) token.getPrincipal();
        // 密码
        String password = new String((char[]) token.getCredentials());

        // 用户名错误
        if (!"zhang".equals(username)) {
            throw new UnknownAccountException();
        }

        // 密码错误
        if (!"123".equals(password)) {
            throw new IncorrectCredentialsException();
        }

        // 如果身份验证成功, 则返回一个 AuthenticationInfo 的实现
        return new SimpleAuthenticationInfo(username, password, getName());
    }

    /**
     * 授权
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        return null;
    }
}
```

#### 测试
```java
package com.laolang.jx.customrealm;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.testng.Assert;
import org.testng.annotations.Test;

@Slf4j
public class CustomRealmTest {

    @Test
    public void testCustomRealm() {
        String iniPath = "classpath:com/laolang/jx/customrealm/shiro-custom-realm.ini";
        // 1. 获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager
        Factory<SecurityManager> factory = new IniSecurityManagerFactory(iniPath);
        // 2. 得到SecurityManager实例 并绑定给SecurityUtils
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");

        try {
            // 4. 登录
            subject.login(token);
        } catch (AuthenticationException e) {
            // 5. 身份验证失败
            log.error("身份验证失败 :{}", ExceptionUtils.getMessage(e));
        }

        Assert.assertTrue(subject.isAuthenticated());

        // 6. 退出
        subject.logout();
    }
}
```

## Authenticator及AuthenticationStrategy

### 介绍

`Authenticator` 的职责是验证用户帐号，是 `Shiro` 中身份验证核心的入口点
```java
public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  throws AuthenticationException;   
```
如果验证成功，将返回 `AuthenticationInfo` 验证信息；此信息中包含了身份及凭证；如果验证失败将抛出相应的 `AuthenticationException` 实现。

`SecurityManager` 接口继承了 `Authenticator` ，另外还有一个 `ModularRealmAuthenticator` 实现，其委托给多个 `Realm` 进行验证，验证规则通过 `AuthenticationStrategy` 接口指定，默认提供的实现：

* `FirstSuccessfulStrategy`：只要有一个 `Realm` 验证成功即可，只返回第一个 `Realm` 身份验证成功的认证信息，其他的忽略；
* `AtLeastOneSuccessfulStrategy`：只要有一个 `Realm` 验证成功即可，和 `FirstSuccessfulStrategy` 不同，返回所有Realm身份验证成功的认证信息；
*`AllSuccessfulStrategy`：所有 `Realm` 验证成功才算成功，且返回所有 `Realm` 身份验证成功的认证信息，如果有一个失败就失败了。

`ModularRealmAuthenticator` 默认使用 `AtLeastOneSuccessfulStrategy` 策略。

### 如何使用

#### PlatformType.java
```java
package com.laolang.jx.multirealm.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Realm 类型
 */
@Getter
@AllArgsConstructor
public enum PlatformType {

    MyRealm("myRealm", "简单 Realm"),
    MyAuthorizingRealm("myAuthorizingRealm", "带认证和授权的 Realm");

    private final String realmName;
    private final String desc;
}
```

#### CustomToken.java
```java
package com.laolang.jx.multirealm.token;

import com.laolang.jx.multirealm.enums.PlatformType;
import lombok.Data;
import lombok.EqualsAndHashCode;
import org.apache.shiro.authc.UsernamePasswordToken;

@EqualsAndHashCode(callSuper = true)
@Data
public class CustomToken extends UsernamePasswordToken {

    private PlatformType platformType;

    public CustomToken(String username, String password, PlatformType platformType) {
        super(username, password);
        this.platformType = platformType;
    }
}
```

#### MyRealm.java
```java
package com.laolang.jx.multirealm.realm;

import lombok.extern.slf4j.Slf4j;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.realm.Realm;

@Slf4j
public class MyRealm implements Realm {

    @Override
    public String getName() {
        return "myRealm";
    }

    /**
     * 仅支持  UsernamePasswordToken
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        return token instanceof UsernamePasswordToken;
    }

    @Override
    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        log.info("{} getAuthenticationInfo execute", getName());
        // 用户名
        String username = (String) token.getPrincipal();
        // 密码
        String password = new String((char[]) token.getCredentials());

        // 用户名错误
        if (!"zhang".equals(username)) {
            throw new UnknownAccountException();
        }

        // 密码错误
        if (!"123".equals(password)) {
            throw new IncorrectCredentialsException();
        }

        // 如果身份验证成功, 则返回一个 AuthenticationInfo 的实现
        return new SimpleAuthenticationInfo(username, password, getName());
    }
}
```

#### MyAuthorizingRealm.java
```java
package com.laolang.jx.multirealm.realm;

import lombok.extern.slf4j.Slf4j;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

@Slf4j
public class MyAuthorizingRealm extends AuthorizingRealm {

    @Override
    public String getName() {
        return "myAuthorizingRealm";
    }

    /**
     * 认证
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        log.info("{} getAuthenticationInfo execute", getName());

        // 用户名
        String username = (String) token.getPrincipal();
        // 密码
        String password = new String((char[]) token.getCredentials());

        // 用户名错误
        if (!"zhang".equals(username)) {
            throw new UnknownAccountException();
        }

        // 密码错误
        if (!"123".equals(password)) {
            throw new IncorrectCredentialsException();
        }

        // 如果身份验证成功, 则返回一个 AuthenticationInfo 的实现
        return new SimpleAuthenticationInfo(username, password, getName());
    }

    /**
     * 授权
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        return null;
    }
}
```

#### CustomModularRealmAuthenticator.java
```java
package com.laolang.jx.multirealm.authc;

import cn.hutool.core.util.StrUtil;
import com.laolang.jx.multirealm.enums.PlatformType;
import com.laolang.jx.multirealm.token.CustomToken;
import java.util.ArrayList;
import java.util.Collection;
import lombok.extern.slf4j.Slf4j;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.pam.ModularRealmAuthenticator;
import org.apache.shiro.realm.Realm;

@Slf4j
public class CustomModularRealmAuthenticator extends ModularRealmAuthenticator {

    @Override
    protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {
        log.info("CustomModularRealmAuthenticator.doAuthenticate execute");
        // 判断 getRealms 是否返回为空
        assertRealmsConfigured();

        // 强转为自定义的 Token
        CustomToken token = (CustomToken) authenticationToken;

        // 登录类型
        PlatformType platformType = token.getPlatformType();

        // 只处理 token 中的登录类型
        Collection<Realm> realms = getRealms();

        Collection<Realm> customRealms = new ArrayList<>();
        for (Realm realm : realms) {
            if(StrUtil.equals(realm.getName(),platformType.getRealmName())){
                customRealms.add(realm);
            }
        }

        // 此处使用过滤后的 Realm 集合, 在此案例中, 就是走 doSingleRealmAuthentication
        if (customRealms.size() == 1) {
            log.info("doSingleRealmAuthentication execute");
            return doSingleRealmAuthentication(customRealms.iterator().next(), authenticationToken);
        } else {
            log.info("doMultiRealmAuthentication execute");
            return doMultiRealmAuthentication(customRealms, authenticationToken);
        }
    }
}
```

#### 测试
```java
package com.laolang.jx.multirealm;

import com.laolang.jx.multirealm.enums.PlatformType;
import com.laolang.jx.multirealm.token.CustomToken;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.testng.Assert;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

@Slf4j
public class MultiRealmTest {

    @BeforeClass
    public void beforeClass() {
        // 1. 获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager
        String iniPath = "classpath:com/laolang/jx/multirealm/shiro-multi-realm.ini";
        Factory<SecurityManager> factory = new IniSecurityManagerFactory(iniPath);
        // 2. 得到SecurityManager实例 并绑定给SecurityUtils
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
    }

    @Test
    public void testMyRealm() {
        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new CustomToken("zhang", "123", PlatformType.MyRealm);

        try {
            // 4. 登录
            subject.login(token);
        } catch (AuthenticationException e) {
            // 5. 身份验证失败
            log.error("身份验证失败 :{}", ExceptionUtils.getMessage(e));
        }

        Assert.assertTrue(subject.isAuthenticated());

        // 6. 退出
        subject.logout();
    }

    @Test
    public void testMyAuthorizingRealm() {
        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new CustomToken("zhang", "123", PlatformType.MyAuthorizingRealm);

        try {
            // 4. 登录
            subject.login(token);
        } catch (AuthenticationException e) {
            // 5. 身份验证失败
            log.error("身份验证失败 :{}", ExceptionUtils.getMessage(e));
        }

        Assert.assertTrue(subject.isAuthenticated());

        // 6. 退出
        subject.logout();
    }
}
```

#### 效果
```
INFO  o.a.s.config.IniSecurityManagerFactory   - Realms have been explicitly set on the SecurityManager instance - auto-setting of realms will not occur.
INFO  .l.j.m.a.CustomModularRealmAuthenticator - CustomModularRealmAuthenticator.doAuthenticate execute
INFO  .l.j.m.a.CustomModularRealmAuthenticator - doSingleRealmAuthentication execute
INFO  c.l.j.m.realm.MyAuthorizingRealm         - myAuthorizingRealm getAuthenticationInfo execute
INFO  a.s.s.m.AbstractValidatingSessionManager - Enabling session validation scheduler...
INFO  .l.j.m.a.CustomModularRealmAuthenticator - CustomModularRealmAuthenticator.doAuthenticate execute
INFO  .l.j.m.a.CustomModularRealmAuthenticator - doSingleRealmAuthentication execute
INFO  com.laolang.jx.multirealm.realm.MyRealm  - myRealm getAuthenticationInfo execute
```

### 参考

[springboot shiro 多realm配置认证、授权](https://www.cnblogs.com/skyLogin/p/10871347.html)
[shiro配置多个realm的方式](https://blog.csdn.net/weixin_43897590/article/details/105890842)

## 关于密码加密

### 加密工具类

#### EncryptInfo.java
```java
package com.laolang.jx.encrypt.encrypt;

import lombok.Builder;
import lombok.Data;

/**
 * 散列信息
 */
@Builder
@Data
public class EncryptInfo {

    /**
     * 加密算法
     */
    private String algorithmName;

    /**
     * 明文
     */
    private String input;

    /**
     * 随机盐
     */
    private String salt;

    /**
     * 密文
     */
    private String password;
}
```

#### EncryptUtil.java
```java
package com.laolang.jx.encrypt.encrypt;

import lombok.experimental.UtilityClass;
import org.apache.shiro.crypto.SecureRandomNumberGenerator;
import org.apache.shiro.crypto.hash.SimpleHash;

@UtilityClass
public class EncryptUtil {

    private static final String SHA1 = "SHA1";
    private static final Integer ITERATIONS = 1;

    /**
     * sha1 散列
     *
     * @param input 输入
     * @param salt  盐
     * @return 散列后的字符串
     */
    public static String sha1(String input, String salt) {
        return new SimpleHash(SHA1, input, salt, ITERATIONS).toString();
    }

    /**
     * 生成随机盐
     *
     * @return 随机盐
     */
    public static String generateSalt() {
        SecureRandomNumberGenerator generator = new SecureRandomNumberGenerator();
        return generator.nextBytes().toHex();
    }

    /**
     * 根据明文密码生成 SHA-1 的散列信息对象
     *
     * @param passwordPlain 明文密码
     * @return 散列后的信息
     * @see EncryptInfo
     */
    public static EncryptInfo entryptSha512Password(String passwordPlain) {
        String salt = generateSalt();
        return EncryptInfo.builder()
                .input(passwordPlain)
                .salt(salt)
                .algorithmName(SHA1)
                .password(sha1(passwordPlain, salt))
                .build();
    }
}
```

#### 测试
```java
package com.laolang.jx.encrypt.encrypt;

import lombok.experimental.UtilityClass;
import org.apache.shiro.crypto.SecureRandomNumberGenerator;
import org.apache.shiro.crypto.hash.SimpleHash;

@UtilityClass
public class EncryptUtil {

    private static final String SHA1 = "SHA1";
    private static final Integer ITERATIONS = 1;

    /**
     * sha1 散列
     *
     * @param input 输入
     * @param salt  盐
     * @return 散列后的字符串
     */
    public static String sha1(String input, String salt) {
        return new SimpleHash(SHA1, input, salt, ITERATIONS).toString();
    }

    /**
     * 生成随机盐
     *
     * @return 随机盐
     */
    public static String generateSalt() {
        SecureRandomNumberGenerator generator = new SecureRandomNumberGenerator();
        return generator.nextBytes().toHex();
    }

    /**
     * 根据明文密码生成 SHA-1 的散列信息对象
     *
     * @param passwordPlain 明文密码
     * @return 散列后的信息
     * @see EncryptInfo
     */
    public static EncryptInfo entryptSha512Password(String passwordPlain) {
        String salt = generateSalt();
        return EncryptInfo.builder()
                .input(passwordPlain)
                .salt(salt)
                .algorithmName(SHA1)
                .password(sha1(passwordPlain, salt))
                .build();
    }
}
```

输出如下
```
fb25c3d608a15157d9d9d1ad8a009e8a
123
07668092e661f3c44125731c136af43ba5d28c4e
```

### Realm 使用密码
#### Realm
```java
package com.laolang.jx.encrypt;

import com.laolang.jx.encrypt.encrypt.EncryptInfo;
import com.laolang.jx.encrypt.encrypt.EncryptUtil;
import java.util.Objects;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.util.ByteSource;

public class CustomAuthorizingRealmWithEncrypt extends AuthorizingRealm {

    public CustomAuthorizingRealmWithEncrypt() {
        //指定密码匹配方式为sha1
        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(EncryptUtil.SHA1);
        //指定密码迭代次数
        matcher.setHashIterations(EncryptUtil.ITERATIONS);
        //使用父类方法使匹配方式生效
        setCredentialsMatcher(matcher);
    }

    @Override
    public String getName() {
        return "customAuthorizingRealmWithEncrypt";
    }

    /**
     * 认证
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // 用户名
        String username = (String) token.getPrincipal();
        // 密码
        String password = new String((char[]) token.getCredentials());

        EncryptInfo encryptInfo = queryUserInfo(token);

        // 用户名错误
        if (Objects.isNull(encryptInfo)) {
            throw new UnknownAccountException();
        }

        // 这里就不需要了
        /* // 密码错误
        if (!"123".equals(password)) {
            throw new IncorrectCredentialsException();
        } */

        // 如果身份验证成功, 则返回一个 AuthenticationInfo 的实现
        return new SimpleAuthenticationInfo(username, encryptInfo.getPassword(), ByteSource.Util.bytes(encryptInfo.getSalt()), getName());
    }

    /**
     * 模拟用户查询
     */
    private EncryptInfo queryUserInfo(AuthenticationToken token) {
        return EncryptInfo.builder()
                .salt("fb25c3d608a15157d9d9d1ad8a009e8a")
                .algorithmName(EncryptUtil.SHA1)
                .password("07668092e661f3c44125731c136af43ba5d28c4e")
                .build();
    }

    /**
     * 授权
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        return null;
    }
}
```

#### ini
```ini
# 声明一个 realm
customAuthorizingRealmWithEncrypt=com.laolang.jx.encrypt.CustomAuthorizingRealmWithEncrypt
# 指定securityManager的realms实现
securityManager.realms=$customAuthorizingRealmWithEncrypt
```

#### 测试
```java
package com.laolang.jx.encrypt;

import cn.hutool.core.collection.CollUtil;
import com.laolang.jx.encrypt.encrypt.EncryptUtil;
import java.util.HashSet;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.testng.Assert;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;
import org.testng.collections.Lists;

@Slf4j
public class EncryptTest {

    @Test
    public void testEncrypt() {
        String salt = EncryptUtil.generateSalt();
        String input = "123";
        System.out.println(salt);
        System.out.println(input);
        System.out.println(EncryptUtil.sha1(input, salt));
        List<String> list = Lists.newArrayList();
        for (int i = 0; i < 10; i++) {
            list.add(EncryptUtil.sha1(input, salt));
        }
        HashSet<String> set = new HashSet<>(list);
        Assert.assertTrue(CollUtil.isNotEmpty(set));
        Assert.assertEquals(set.size(), 1);
    }

    @BeforeClass
    public void beforeClass() {
        // 1. 获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager
        String iniPath = "classpath:com/laolang/jx/encrypt/shiro-custom-authorizing-realm-with-encrypt.ini";
        Factory<SecurityManager> factory = new IniSecurityManagerFactory(iniPath);
        // 2. 得到SecurityManager实例 并绑定给SecurityUtils
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);

    }

    @Test
    public void testRealmWithEncrypt() {
        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");

        try {
            // 4. 登录
            subject.login(token);
        } catch (AuthenticationException e) {
            // 5. 身份验证失败
            log.error("身份验证失败 :{}", ExceptionUtils.getMessage(e));
        }

        Assert.assertTrue(subject.isAuthenticated());

        // 6. 退出
        subject.logout();
    }

    @Test(expectedExceptions = IncorrectCredentialsException.class)
    public void testRealmWithEncryptErrorPassword() {
        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken("zhang", "xxx");

        // 4. 登录
        subject.login(token);
    }
}
```

## 授权

### realm
```java
package com.laolang.jx.auth;

import com.laolang.jx.encrypt.encrypt.EncryptInfo;
import com.laolang.jx.encrypt.encrypt.EncryptUtil;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.util.ByteSource;

public class MyRealm extends AuthorizingRealm {

    public MyRealm() {
        //指定密码匹配方式为sha1
        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(EncryptUtil.SHA1);
        //指定密码迭代次数
        matcher.setHashIterations(EncryptUtil.ITERATIONS);
        //使用父类方法使匹配方式生效
        setCredentialsMatcher(matcher);
    }

    @Override
    public String getName() {
        return "myRealm";
    }

    /**
     * 认证
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // 用户名
        String username = (String) token.getPrincipal();
        // 密码
        String password = new String((char[]) token.getCredentials());

        EncryptInfo encryptInfo = queryUserInfo(token);

        // 用户名错误
        if (Objects.isNull(encryptInfo)) {
            throw new UnknownAccountException();
        }

        // 这里就不需要了
        /* // 密码错误
        if (!"123".equals(password)) {
            throw new IncorrectCredentialsException();
        } */

        // 如果身份验证成功, 则返回一个 AuthenticationInfo 的实现
        return new SimpleAuthenticationInfo(username, encryptInfo.getPassword(), ByteSource.Util.bytes(encryptInfo.getSalt()), getName());
    }

    /**
     * 模拟用户查询
     */
    private EncryptInfo queryUserInfo(AuthenticationToken token) {
        return EncryptInfo.builder()
                .salt("fb25c3d608a15157d9d9d1ad8a009e8a")
                .algorithmName(EncryptUtil.SHA1)
                .password("07668092e661f3c44125731c136af43ba5d28c4e")
                .build();
    }

    /**
     * 授权
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        // 用户名
        String username = (String) principals.getPrimaryPrincipal();

        // 模拟查询用户权限
        Set<String> roles = new HashSet<>();
        roles.add("admin");
        roles.add("seller");
        Set<String> perms = new HashSet<>();
        perms.add("admin:system:dict:typeList");
        perms.add("seller:product:getInfo");

        // 构建资源校验
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.addRoles(roles);
        info.addStringPermissions(perms);
        return info;
    }
}
```

### ini
```ini
# 声明一个 realm
myRealm= com.laolang.jx.auth.MyRealm
# 指定securityManager的realms实现
securityManager.realms=$myRealm
```

### 测试
```java
package com.laolang.jx.auth;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.authz.UnauthorizedException;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

@Slf4j
public class AuthTest {

    private Subject subject;

    @BeforeClass
    public void beoreClass() {
        // 1. 获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager
        String iniPath = "classpath:com/laolang/jx/auth/shiro-auth.ini";
        Factory<SecurityManager> factory = new IniSecurityManagerFactory(iniPath);
        // 2. 得到SecurityManager实例 并绑定给SecurityUtils
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);

        // 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
        subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");

        try {
            // 4. 登录
            subject.login(token);
        } catch (AuthenticationException e) {
            // 5. 身份验证失败
            log.error("身份验证失败 :{}", ExceptionUtils.getMessage(e));
        }

        Assert.assertTrue(subject.isAuthenticated());
    }

    @AfterClass
    public void afterClass(){
        subject.logout();
    }

    @Test
    public void testAuth() {
        // 验证角色
        subject.checkRole("admin");

        // 验证权限
        subject.checkPermission("admin:system:dict:typeList");
    }

    @Test(expectedExceptions = UnauthorizedException.class)
    public void testNoAuth(){
        subject.checkRole("xxx");
    }

    @Test(expectedExceptions = UnauthorizedException.class)
    public void testNoPerm(){
        subject.checkPermission("xxx");
    }
}
```

# shiro + ssm